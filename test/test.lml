
module Test:sig

  type t = int32 * int32

  and t2 = 
    | Tata of t
    | Bob of int32

  type 'a list = 
    | Empty
    | Cons of 'a * 'a list

  val fac: int32 -> int32

end = struct
  module B = Bo

  let rec fac n = 
    if n <= 0
    then 1 
    else n * fac (n-1)


end

module Bo: sig end = struct 

  module L = Test

  let rec rev acc l = 
    match l with
    | L.Empty -> acc
    | L.Cons (x, rl) -> rev (L.Cons (x, acc)) rl
    
end
