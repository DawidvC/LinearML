
module Map = struct

  type t = 
    | Empty
    | Cons of int32 * t
    | Lazy of t future


  val f: int32 * int32 -> int32
  let f acc n = 
    if n = 0
    then acc
    else f (acc+n) (n-1)

  val rev_append: t * t -> t
  let rev_append l1 l2 = 
    match l1 with
    | Empty -> l2
    | Cons x rl -> rev_append rl (Cons x l2)
    | Lazy l -> rev_append (wait l) l2


  val merge: t * t * t -> t
  let merge acc l1 l2 = 
    match l1, l2 with
    | Lazy l1, l2 -> merge acc (wait l1) l2
    | l1, Lazy l2 -> merge acc l1 (wait l2)
    | Empty, l -> rev_append l acc
    | l, Empty -> rev_append l acc
    | (Cons x1 rl1 as l1), (Cons x2 rl2 as l2) ->
	if x1 > x2
	then merge (Cons x1 acc) rl1 l2
	else merge (Cons x2 acc) l1 rl2


end
