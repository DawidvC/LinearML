
(*****************************************************************************)
(* Active hashtable *)
(*****************************************************************************)
module HashTableProc: sig

  type ('a, 'b) msg = 
    | Find 'a
    | Write ('a, 'b)

  type ('a, 'b) t = ('a msg, 'b shared option) Actor.t

  val make: int -> ('a, 'b) t

end = struct

  let handler ht msg = 
    match msg with
    | Find s -> ht, Hashtbl.get ht s
    | Write (s, v) ->
	let ht, x = Hashtbl.replace ht s v in
	(match x with
	| None -> ()
	| Some x -> free x) ;
	ht, None

  let make size = 
    let initial_state = Hashtbl.create size in
    Actor.make handler initial_state
end

(*****************************************************************************)
module Merger: sig

  type t = (int list promis * int list promis, int list) Actor.t
  val make: unit -> t
end = struct

  let handler (l1, l2) = 
    let l1 = wait l1 in (* Garanti de finir (sauf en cas de boucle infinie) *)
    let l2 = wait l2 in
    intersect (sort l1) (sort l2)

  let make() = Actor.make_fun handler
end

(*****************************************************************************)
module ChordedHashtblProc: sig

  type abstract state = {
      hash: (string -> int) ;
      sons: (string, int list) HashTableProc.t array ;
      mergers: Merger.t array ;
    }

  type msg = 
    | Write of string * int list
    | Find of string
    | And of string * string

  val make: int -> int -> (msg, int list) Actor.t

end = struct

  let chord st x = st.sons.(st.hash x mod Array.length st.sons)

  let handler st msg = 
    match msg with
    | Write (x, y) ->
	let son = chord st x in
	st, send son (Write (x, y))
    | Find x -> 
	let son = chord st x in
	st, send son (Find x)
    | And (x, y) -> 
	let l1 = chord x in
	let l2 = chord y in
	let merger = select st.mergers in
	st, send merger (l1, l2)

  let make size nbr_mergers = 
    let sons = Array.make HashTableProc.make size in
    let mergers = Array.make Merber.make nbr_mergers in
    Actor.make handler { sons, mergers } 
end
